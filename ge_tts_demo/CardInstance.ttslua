local Instance = require('ge_tts/Instance')
local TableUtils = require('ge_tts/TableUtils')

--
-- Here we declare a Luanalysis sub class of ge_tts/Instance,
-- in the type system it is known as ge_tts__Instance. our
-- subclass is called CardInstance.
--
-- In ge_tts, an Instance represents the concept of a game piece,
-- it's persistent unlike TTS objects, which are destroyed when
-- placed in a bag or deck. Instead, ge_tts instances continue to
-- exist, and you can even call its methods like instance.destroy()
-- whilst it's in a container; in which case ge_tts will remove it
-- from the container (and you should discard your reference to the
-- instance).
--

---@class CardInstance : ge_tts__Instance

--
-- Everything in TTS should be able to be saved and loaded
-- such that saved games and rewind work. Here we declare a
-- Luanalysis OF ge_tts__Instance_SavedState called
-- CardInstance_SavedState and you add any game specific
-- data associated with this card (in play).
--

---@shape CardInstance_SavedState : ge_tts__Instance_SavedState
---@field card Card

--
-- The game specific data we added is just a single field, which is the game's card data for this
-- card instance. Please refer to Card.ttslua
--

--
-- In Lua, each file should return something. When you require a file, you
-- gain access to whatever was returned. What we're doing to do now is
-- declare type information for what this file returns. Internally it's
-- a local variable called CardInstance, however the global type name
-- (which works in any file) is static_CardInstance. You're unlikely
-- to directly reference this type name, but you can if you wish.
-- It inherits from ge_tts__static_Instance for convenience, so all it's
-- static methods are accessible on CardInstance.
--
-- CardInstance is a callable type (has overloads), it's a constructor which
-- creates a CardInstance (declared above). We've got three overloads,
-- but really that's up to you. In this case they are:
--
-- 1. Accepts a card (your custom game data), and a TTS object (presumably a
--    TTS card).
--
-- 2. A card, an *instance GUID*, and a TTS *container*. You use this constructor
--    when your card is in a deck. The GUID is the instance GUID (the GUID in the
--    deck), and the container is the deck.
--    NOTE: There are special instance GUID semantics, we'll get to those.
--
-- 3. Saved state.
--    ge_tts knows how to restore references to TTS objects in a save using this
--    saved state. In fact, when used correctly, ge_tts will automatically recover
--    objects that *should* exist in a save, but don't because a save occurred when
--    they were half-way through spawning!
--    Anyway, you call this constructor when restoring from a saved state. To
--    *obtain* this saved (in response to an onSave) you simply call instance.save(),
--    and it'll return a saved state that you must persist yourself (your own data
--    structure that you'll return from onSave - typically JSON).
--
--

---@class static_CardInstance : ge_tts__static_Instance
---@overload fun(card: Card, object: tts__Object): CardInstance
---@overload fun(card: Card, guid: string, container: tts__Container): CardInstance
---@overload fun(savedState: CardInstance_SavedState): CardInstance
local CardInstance = {}

--
-- Each ge_tts instance should have a unique "instance type". Technically ge_tts
-- doesn't even use this info itself, however it's useful for *you*. The following
-- declaration is a convenience, whereby we expose that unique type on CardInstance
-- itself. You could just as easily compare strings "Card" all through-out your code.
--

CardInstance.INSTANCE_TYPE = "Card"

--
-- What follows is how we declare a ge_tts style subclass. As mentioned above
-- static_CardInstance inherits from ge_tts__static_Instance, so what
-- we're doing is copying the Instance metatable, and replace some fields.
-- Namely __call (our constructor), and __index, which we set to Instance,
-- and hence any fields not present on CardInstance will be looked for up
-- the "inheritance chain" on Instance.
--
-- NOTE: This metatable stuff only deals with the *static* CardInstance.
--

setmetatable(CardInstance, TableUtils.merge(getmetatable(Instance), {
    --- Here is on constructor, the type definition is a bit complicated, it's
    --- the combination of all three of our overloads!
    ---@param cardOrSavedState Card | CardInstance_SavedState
    ---@param nilOrObjectOrGuid nil | tts__Object | string
    ---@param nilOrContainer nil | tts__Container
    __call = function(_, cardOrSavedState, nilOrObjectOrGuid, nilOrContainer)
        -- Here we check whether we've been passed a saved state.
        local isSavedState = CardInstance.isSavedState(cardOrSavedState)

        --
        -- If we have, we pass that to our super constructor Instance(), otherwise
        -- we pass on the object GUID (guaranteed to not be nil at this point), and
        -- the container (which may be nil, if the card isn't in a container).
        --
        -- NOTE: We're casting from ge_tts__Instance to CardInstance, because
        --       we're about to add all the fields for a CardInstance onto it.
        --
        local self = --[[---@type CardInstance]] (
            isSavedState and Instance(--[[---@type CardInstance_SavedState]] cardOrSavedState)
                or Instance(--[[---@not nil]] nilOrObjectOrGuid, nilOrContainer)
        )

        -- Here we create a private variable belonging to this instance, it can't be
        -- accessed externally. It's storing the aforementioned card data, which is
        -- up to you.

        ---@type Card
        local card

        -- Seems as we want each type of instant to have its own type, we *must* implement a method
        -- called getInstanceType(). It takes no parameters, and returns the instance type.

        ---@return string
        function self.getInstanceType()
            return CardInstance.INSTANCE_TYPE
        end

        -- Next, we probably want to be able to get access to the card data associated with a card
        -- instance that's in play, so we expose that.

        ---@return Card
        function self.getCard()
            return card
        end

        -- Finally, we *override* save(). It's *very* important how we go about doing this. We must
        -- return our own data, but also return ge_tts__Instance. This is achieved by first grabbing
        -- a reference this existing save() method ge_tts__Instance...

        local superSave = self.save

        -- Then, we replace this method with our own implementation...

        ---@return CardInstance_SavedState
        function self.save()
            -- We *must* merge our data with ge_tts__Instance, so we call through to the original
            -- (super) save() method, and merge the data returned with our own data i.e. the card
            -- data associated with this instance.

            return --[[---@type CardInstance_SavedState]] TableUtils.merge(superSave(), {
                card = card,
            })
        end

        if isSavedState then
            -- If we're restoring from a saved state, we restore the card data from
            -- the saved state.

            local data = --[[---@type CardInstance_SavedState]] cardOrSavedState
            card = data.card
        else
            -- If not, then we know this constructor was called with the necessary
            -- card data, thus we cast it.
            card = --[[---@type Card]] cardOrSavedState
        end

        return self
    end,

    -- As stated above, for convenience we make all methods provided by Instance available on
    -- CardInstance. Actually, you'l note we already took advantage of this fact in our
    -- constructor, where we used CardInstance.isSavedState instead of Instance.isSavedState.
    __index = Instance,
}))

-- We return our CardInstance, a callable static table.

return CardInstance
